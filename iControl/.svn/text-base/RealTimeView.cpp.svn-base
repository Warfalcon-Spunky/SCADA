// RealTimeView.cpp : implementation file
//

#include "stdafx.h"
#include "iControl.h"
#include "iControlDoc.h"
#include "RealTimeView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_LINE_PORT_NUM		6				// 一行显示的表头个数
#define THE_BACKGROUD_COLOR		RGB(0, 0, 0)	// 视图背景颜色

#define THE_IN_TEMP_SEGMENT_COLOR		RGB(64, 255, 64)
#define THE_IN_TEMP_SEGMENTBK_COLOR		RGB(48, 48, 48)

#define THE_OUT_TEMP_SEGMENT_COLOR		RGB(255, 64, 64)
#define THE_OUT_TEMP_SEGMENTBK_COLOR	RGB(48, 48, 48)

#define THE_OTHER_SEGMENT_COLOR			RGB(64, 255, 64)
#define THE_OTHER_SEGMENTBK_COLOR		RGB(48, 48, 48)

#define THE_CAPTION_FT_COLOR			RGB(0, 128, 255)

#define THE_UPDATE_TIME					2					// 自我更新定时设置

/////////////////////////////////////////////////////////////////////////////
// CRealTimeView

IMPLEMENT_DYNCREATE(CRealTimeView, CView)

CRealTimeView::CRealTimeView()
{
	m_iCurrentFurnaceNum = -1;
	m_iOldFurnaceNum = -1;

	m_bFirstPaint = FALSE;
}

CRealTimeView::~CRealTimeView()
{
}


BEGIN_MESSAGE_MAP(CRealTimeView, CView)
	//{{AFX_MSG_MAP(CRealTimeView)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_MOVE()
	ON_WM_DESTROY()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRealTimeView drawing

void CRealTimeView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CRealTimeView diagnostics

#ifdef _DEBUG
void CRealTimeView::AssertValid() const
{
	CView::AssertValid();
}

void CRealTimeView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRealTimeView message handlers

void CRealTimeView::OnInitialUpdate() 
{
	CView::OnInitialUpdate();
	
	// 获取文档相关参数
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetApp()->m_pMainWnd;
	CIControlDoc *pDoc     = (CIControlDoc *)pMainFrame->GetActiveDocument();
	if (pDoc->m_bDBOpen == FALSE)		// 相关数据库打开和数据初始化为成功
	{
		PostQuitMessage(1);				// 退出程序
		return;
	}

	m_iKilnNum = pDoc->m_iKilnNum;

	m_pPortNum = new int[m_iKilnNum];
	for (int n = 0; n < m_iKilnNum; n++)
	{
		// 计算每条窑表头总数
		m_pPortNum[n] = pDoc->m_pKilnBuffForCurve[n].TemperatureNum 
						+ pDoc->m_pKilnBuffForCurve[n].TemperatureANum
						+ pDoc->m_pKilnBuffForCurve[n].PressNum 
						+ pDoc->m_pKilnBuffForCurve[n].HumidityNum 
						+ pDoc->m_pKilnBuffForCurve[n].MotorNum;		
	}

	pMainFrame->GetClientRect(m_MaxClientRect);

	BITMAPINFO bmpinfo;
	bmpinfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmpinfo.bmiHeader.biWidth = GetSystemMetrics(SM_CXSCREEN);   // 创建最大的图片, 尺寸宽度为屏幕尺寸宽度
	bmpinfo.bmiHeader.biHeight = GetSystemMetrics(SM_CYSCREEN);  // 创建最大的图片, 尺寸高度为屏幕尺寸宽度
	bmpinfo.bmiHeader.biPlanes = 1;
	bmpinfo.bmiHeader.biBitCount = 32;
	bmpinfo.bmiHeader.biCompression = BI_RGB;
	bmpinfo.bmiHeader.biSizeImage = 0;
	bmpinfo.bmiHeader.biXPelsPerMeter = 0;
	bmpinfo.bmiHeader.biYPelsPerMeter = 0;
	bmpinfo.bmiHeader.biClrUsed = 0;
	bmpinfo.bmiHeader.biClrImportant = 0;
	
	CDC *pDC = GetDC();
	m_MemDcDraw.CreateCompatibleDC(pDC);
	m_HbtMap = CreateDIBSection(m_MemDcDraw, &bmpinfo, DIB_RGB_COLORS, NULL, NULL, 0);
	m_MemDcDraw.SelectObject(m_HbtMap);
	m_MemDcDraw.SetBkMode(TRANSPARENT);
	ReleaseDC(pDC);

//	SetTimer(0, THE_UPDATE_TIME * 1000, NULL);
}

void CRealTimeView::InitSegPort(void)
{
	// 获取文档相关参数
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetApp()->m_pMainWnd;
	CIControlDoc *pDoc     = (CIControlDoc *)pMainFrame->GetActiveDocument();

	int i, j, k, m;
	CRect PortRect;
	int wid = m_MaxClientRect.Width() / MAX_LINE_PORT_NUM;
	int hid;
 	if (m_pPortNum[m_iCurrentFurnaceNum] > 24)
	{
		hid = (int)((float)wid * 0.5F);
	}
	else
	{
		hid = (int)((float)wid * 0.618F);
	}

	m_pRTPort = new LPRTV[m_iKilnNum];	// 建立结构体指针缓冲区
	for (i = 0; i < m_iKilnNum; i++)
	{
		m_pRTPort[i] = new RTV;			// 建立结构体实体

		// 创建表头指针缓冲区
		m_pRTPort[i]->m_pSegPort = new CiSevenSegmentAnalogX *[m_pPortNum[i]];
		
		for (k = 0, m = 0, j = 0; j < m_pPortNum[i]; j++)
		{
			PortRect.left = 6 + m * wid;
			PortRect.right = PortRect.left + wid;
			PortRect.top = 120 + k * hid;
			PortRect.bottom = PortRect.top + hid;
			
			m = (m + 1) % MAX_LINE_PORT_NUM;
			if (m == 0)
			{
				k++;			
			}
			
			// 创建表头实体
			m_pRTPort[i]->m_pSegPort[j] = new CiSevenSegmentAnalogX;
			m_pRTPort[i]->m_pSegPort[j]->Create("", WS_CHILD | WS_VISIBLE, PortRect, this, 50800 + j);	
		}

		// 设置温度表头的相关属性
		int iPortNum = 0;
		for (j = iPortNum; j < pDoc->m_pKilnBuffForCurve[i].TemperatureNum; j++)
		{
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentColor(THE_OUT_TEMP_SEGMENT_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);			
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSize(3);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSeperation(2);
			m_pRTPort[i]->m_pSegPort[j]->SetShowSign(TRUE);
			m_pRTPort[i]->m_pSegPort[j]->SetPrecision(0);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitSpacing(10);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitCount(4);			
			m_pRTPort[i]->m_pSegPort[j]->SetValue(10000);
			if (i == 0)
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(TRUE);			
			}
			else
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(FALSE);	
			}	
		}

		iPortNum = iPortNum + pDoc->m_pKilnBuffForCurve[i].TemperatureNum;
		for (j = iPortNum; j < (iPortNum + pDoc->m_pKilnBuffForCurve[i].TemperatureANum); j++)
		{
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentColor(THE_OUT_TEMP_SEGMENT_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);			
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSize(3);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSeperation(2);
			m_pRTPort[i]->m_pSegPort[j]->SetShowSign(TRUE);
			m_pRTPort[i]->m_pSegPort[j]->SetPrecision(0);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitSpacing(10);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitCount(4);			
			m_pRTPort[i]->m_pSegPort[j]->SetValue(10000);
			if (i == 0)
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(TRUE);			
			}
			else
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(FALSE);	
			}		
		}

		iPortNum = iPortNum + pDoc->m_pKilnBuffForCurve[i].TemperatureANum;
		for (j = iPortNum; j < (iPortNum + pDoc->m_pKilnBuffForCurve[i].PressNum); j++)
		{
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentColor(THE_OTHER_SEGMENT_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSize(3);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSeperation(2);
			m_pRTPort[i]->m_pSegPort[j]->SetShowSign(TRUE);
			m_pRTPort[i]->m_pSegPort[j]->SetPrecision(0);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitSpacing(10);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitCount(4);
			m_pRTPort[i]->m_pSegPort[j]->SetValue(10000);
			if (i == 0)
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(TRUE);			
			}
			else
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(FALSE);	
			}
		}

		iPortNum = iPortNum + pDoc->m_pKilnBuffForCurve[i].PressNum;
		for (j = iPortNum; j < (iPortNum + pDoc->m_pKilnBuffForCurve[i].HumidityNum); j++)
		{
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentColor(THE_OTHER_SEGMENT_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSize(3);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSeperation(2);
			m_pRTPort[i]->m_pSegPort[j]->SetShowSign(TRUE);
			m_pRTPort[i]->m_pSegPort[j]->SetPrecision(0);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitSpacing(10);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitCount(4);
			m_pRTPort[i]->m_pSegPort[j]->SetValue(10000);			
			if (i == 0)
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(TRUE);			
			}
			else
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(FALSE);	
			}
		}

		iPortNum = iPortNum + pDoc->m_pKilnBuffForCurve[i].HumidityNum;
		for (j = iPortNum; j < (iPortNum + pDoc->m_pKilnBuffForCurve[i].MotorNum); j++)
		{
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentColor(THE_OTHER_SEGMENT_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSize(3);
			m_pRTPort[i]->m_pSegPort[j]->SetSegmentSeperation(2);
			m_pRTPort[i]->m_pSegPort[j]->SetShowSign(TRUE);
			m_pRTPort[i]->m_pSegPort[j]->SetPrecision(1);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitSpacing(10);
			m_pRTPort[i]->m_pSegPort[j]->SetDigitCount(4);
			m_pRTPort[i]->m_pSegPort[j]->SetValue(10000);			
			if (i == 0)
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(TRUE);			
			}
			else
			{
				m_pRTPort[i]->m_pSegPort[j]->SetVisible(FALSE);	
			}
		}		
	}
}

void CRealTimeView::UpdateView(void)
{
	int i;

	if (m_bFirstPaint == FALSE)
	{
		return;		
	}	

	// 需要显示新的窑数据时才更新表头数量
	if (m_iOldFurnaceNum != m_iCurrentFurnaceNum)
	{
		if (m_iOldFurnaceNum < 0)
		{
			m_iOldFurnaceNum = 0;
		}

		for (i = 0; i < m_pPortNum[m_iOldFurnaceNum]; i++)
		{
 			m_pRTPort[m_iOldFurnaceNum]->m_pSegPort[i]->ShowWindow(SW_SHOW);
 			m_pRTPort[m_iOldFurnaceNum]->m_pSegPort[i]->ShowWindow(SW_HIDE);
		}
		
		for (i = 0; i < m_pPortNum[m_iCurrentFurnaceNum]; i++)
		{
 			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[i]->ShowWindow(SW_SHOW);
		}

		m_iOldFurnaceNum = m_iCurrentFurnaceNum;

		SendMessage(WM_PAINT, 0, 0);
	}

	// 获取文档相关参数
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetApp()->m_pMainWnd;
	CIControlDoc *pDoc     = (CIControlDoc *)pMainFrame->GetActiveDocument();

	int PortIndex = 0;
	
	/************************************************************************/
	/* 实时温度表头显示                                                     */
	/************************************************************************/
	for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum; i++, PortIndex++)
	{
		// 非法温度代表断线
		if ((pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].Value < (-100)) 
			|| (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].Value > 1370))
		{
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(10000);
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetSegmentColor(THE_OUT_TEMP_SEGMENT_COLOR);
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);
		}
		else
		{
			// 显示实时温度值
			if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetValue() != pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].Value)
			{
				m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].Value);
			}			
			
			// 超过标准温度, 红色
//			if (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].Value > pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].SValue)
			if (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].Value > 700)
			{
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetSegmentColor() != THE_OUT_TEMP_SEGMENT_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetSegmentColor(THE_OUT_TEMP_SEGMENT_COLOR);
				}
				
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetBackGroundColor() != THE_OUT_TEMP_SEGMENTBK_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);					
				}				
			}
			// 未超过标准温度, 绿色
			else
			{
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetSegmentColor() != THE_IN_TEMP_SEGMENT_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetSegmentColor(THE_IN_TEMP_SEGMENT_COLOR);
				}
				
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetBackGroundColor() != THE_IN_TEMP_SEGMENTBK_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetBackGroundColor(THE_IN_TEMP_SEGMENTBK_COLOR);
				}				
			}
		}
	} /* End of for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum; i++, PortIndex++) */

	/************************************************************************/
	/* 实时边温度表头显示                                                     */
	/************************************************************************/
	for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum; i++, PortIndex++)
	{
		// 非法温度代表断线
		if ((pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempAObjectBuff[i].Value < (-100)) 
			|| (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempAObjectBuff[i].Value > 1370))
		{
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(10000);
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetSegmentColor(THE_OUT_TEMP_SEGMENT_COLOR);
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);
		}
		else
		{
			// 显示实时温度值
			if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetValue() != pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempAObjectBuff[i].Value)
			{
				m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempAObjectBuff[i].Value);
			}	
			
			if (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempAObjectBuff[i].Value > 700)
			{
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetSegmentColor() != THE_OUT_TEMP_SEGMENT_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetSegmentColor(THE_OUT_TEMP_SEGMENT_COLOR);
				}
				
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetBackGroundColor() != THE_OUT_TEMP_SEGMENTBK_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetBackGroundColor(THE_OUT_TEMP_SEGMENTBK_COLOR);					
				}				
			}
			// 未超过标准温度, 绿色
			else
			{
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetSegmentColor() != THE_IN_TEMP_SEGMENT_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetSegmentColor(THE_IN_TEMP_SEGMENT_COLOR);
				}
				
				if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetBackGroundColor() != THE_IN_TEMP_SEGMENTBK_COLOR)
				{
					m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetBackGroundColor(THE_IN_TEMP_SEGMENTBK_COLOR);
				}				
			}
		}
	} /* End of for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum; i++, PortIndex++) */
	
	/************************************************************************/
	/* 实时压力表头显示                                                     */
	/************************************************************************/
	for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].PressNum; i++, PortIndex++)
	{
		if ((pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pPressObjectBuff[i].Value < (-500)) 
			|| (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pPressObjectBuff[i].Value > 500))
		{
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(10000);
		}
		else
		{
			if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetValue() != pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pPressObjectBuff[i].Value)
			{
				m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pPressObjectBuff[i].Value);
			}
		}
	}

	/************************************************************************/
	/* 实时湿度表头显示                                                     */
	/************************************************************************/
	for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].HumidityNum; i++, PortIndex++)
	{
		if ((pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pHumiObjectBuff[i].Value < 0.0) 
			|| (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pHumiObjectBuff[i].Value > 100.0))
		{
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(10000);
		}
		else
		{
			if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetValue() != pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pHumiObjectBuff[i].Value)
			{
				m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pHumiObjectBuff[i].Value);
			}
		}
	}

	for (i = 0; i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].MotorNum; i++, PortIndex++)
	{
		if ((pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pMotorObjectBuff[i].Value < 0.0) 
			|| (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pMotorObjectBuff[i].Value > 500.0))
		{
			m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(10000);
		}
		else
		{
			// 显示实时变频器值
			if (m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->GetValue() != (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pMotorObjectBuff[i].Value / 10.0))
			{
				m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[PortIndex]->SetValue(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pMotorObjectBuff[i].Value / 10.0);
			}
		}
	}

	// 重绘表头
	for (i = 0; i < m_pPortNum[m_iCurrentFurnaceNum]; i++)
	{
		m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[i]->RepaintAll();
	}
}

void CRealTimeView::ActiveView(int iNewFurnaceNum)
{
	m_iCurrentFurnaceNum = iNewFurnaceNum;

	// 获取文档相关参数
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetApp()->m_pMainWnd;
	CIControlDoc *pDoc     = (CIControlDoc *)pMainFrame->GetActiveDocument();

	CString str;

	switch (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].type)
	{
	case 0:
		str.Format("%d号窑<焙烧窑> 实时数据界面", m_iCurrentFurnaceNum + 1);
		break;
	case 1:
		str.Format("%d号窑<烘干窑> 实时数据界面", m_iCurrentFurnaceNum + 1);
		break;
	case 2:
		str.Format("%d号窑<直通窑> 实时数据界面", m_iCurrentFurnaceNum + 1);
		break;
	case 3:
		str.Format("%d号窑<移动窑> 实时数据界面", m_iCurrentFurnaceNum + 1);
		break;
	default:
		break;
	}
	
	pMainFrame->SetFrameCaption(str);
}

void CRealTimeView::DrawCaption(CDC *pDC)
{
	CRect ClientRect = m_MaxClientRect;

	// 获取文档相关参数
	CMainFrame *pMainFrame = (CMainFrame *)AfxGetApp()->m_pMainWnd;
	CIControlDoc *pDoc     = (CIControlDoc *)pMainFrame->GetActiveDocument();
	
	pDC->SetBkMode(TRANSPARENT);

	// 创建字体
	CFont Font, *pOldFont;
	Font.CreateFont(60, 0, 0, 0, FW_BOLD, 0, 0, 0, GB2312_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, "楷体_GB2312");
	pOldFont = pDC->SelectObject(&Font);

	// 显示提示文字且设置文字颜色
	ClientRect.top = 20;
	ClientRect.bottom = 80;
	pDC->SetTextColor(THE_CAPTION_FT_COLOR);
	pDC->DrawText(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].strCaption, &ClientRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	// 释放字体内存操作
	pDC->SelectObject(pOldFont);
	Font.DeleteObject();

	Font.CreateFont(30, 8, 0, 0, FW_BOLD, 0, 0, 0, GB2312_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, "黑体");
	pOldFont = pDC->SelectObject(&Font);

	int height;
	CString str;
	WINDOWPLACEMENT lpWnd;
	for (int i = 0; i < m_pPortNum[m_iCurrentFurnaceNum]; i++)
	{
		lpWnd.length = sizeof(WINDOWPLACEMENT);
		m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[i]->GetWindowPlacement(&lpWnd);

		height = lpWnd.rcNormalPosition.bottom - lpWnd.rcNormalPosition.top + 1;
		ClientRect = lpWnd.rcNormalPosition;

		ClientRect.top = ClientRect.top + (height * 3 / 4) + 3;
		ClientRect.bottom = ClientRect.bottom + (height * 3 / 4) + 3;
		
		pDC->SetTextColor(THE_CAPTION_FT_COLOR);
		str.Empty();

		// 显示温度测温点指示
		if (i < pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum)
		{
			if (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].type == 3)
			{
				if (strcmp(pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].strName, "自动排号") != 0)
				{
					str.Format("%s温度(℃)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].strName);
				}
				else
				{
					str.Format("%03d米温度(℃)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].CarIdex);
				}
			}
			else
			{
				str.Format("%02d号车位温度(℃)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempObjectBuff[i].CarIdex + 1);
			}
			
			pDC->DrawText(str, &ClientRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
		else if (i < (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
					  + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum))
		{
			str.Format("%s温度(℃)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pTempAObjectBuff[i - pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum].strName);
			pDC->DrawText(str, &ClientRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
		// 显示压力测试点指示
		else if (i < (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
					  + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum
					  + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].PressNum))
		{
			str.Format("%s压力(Pa)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pPressObjectBuff[i 
																								- pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
																								- pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum].strName);
			pDC->DrawText(str, &ClientRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
		// 显示湿度测试点指示
		else if (i < (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].PressNum 
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].HumidityNum))
		{
			str.Format("%s湿度(℃)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pHumiObjectBuff[i 
																							   - pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
																							   - pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum 
																							   - pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].PressNum].strName);
			pDC->DrawText(str, &ClientRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
		// 显示变频器测试点指示
		else if (i < (pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].PressNum 
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].HumidityNum 
					   + pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].MotorNum))
		{
			str.Empty();
			str.Format("%s变频器值(Hz)", pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].m_pMotorObjectBuff[i 
																									- pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureNum 
																									- pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].TemperatureANum 
																									- pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].PressNum 
																									- pDoc->m_pKilnBuffForCurve[m_iCurrentFurnaceNum].HumidityNum].strName);
			pDC->DrawText(str, &ClientRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
	}

	// 释放字体内存操作
	pDC->SelectObject(pOldFont);
	Font.DeleteObject();

	// 表头重绘
	for (i = 0; i < m_pPortNum[m_iCurrentFurnaceNum]; i++)
	{
		m_pRTPort[m_iCurrentFurnaceNum]->m_pSegPort[i]->RepaintAll();
	}
} 

void CRealTimeView::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	if (m_bFirstPaint == FALSE)
	{
		InitSegPort();
		UpdateView();
		m_bFirstPaint = TRUE;
	}

	GetClientRect(m_MaxClientRect);

 	CBrush brBack, *pOldcrBack;
	// 创建刷子并绘制填充矩形, 尺寸为父窗口的客户区大小
	brBack.CreateSolidBrush(THE_BACKGROUD_COLOR);
	m_MemDcDraw.FillRect(&m_MaxClientRect, &brBack);	
	pOldcrBack = m_MemDcDraw.SelectObject(&brBack);	
	
	m_MemDcDraw.SelectObject(pOldcrBack);
	brBack.DeleteObject();	

	// 重绘标题
	DrawCaption(&m_MemDcDraw);
	
	// 送入显存
	CDC *pDC = GetDC();
	pDC->StretchBlt(m_MaxClientRect.left, m_MaxClientRect.top, m_MaxClientRect.Width(), m_MaxClientRect.Height(), &m_MemDcDraw, m_MaxClientRect.left, m_MaxClientRect.top, m_MaxClientRect.Width(), m_MaxClientRect.Height(), SRCCOPY);
	ReleaseDC(pDC);
	
	// Do not call CView::OnPaint() for painting messages
}

BOOL CRealTimeView::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
// 	cs.cx = GetSystemMetrics(SM_CXFULLSCREEN); 
// 	cs.cy = GetSystemMetrics(SM_CYFULLSCREEN);

	return CView::PreCreateWindow(cs);
}

void CRealTimeView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	// TODO: Add your message handler code here	
}

BOOL CRealTimeView::OnEraseBkgnd(CDC* pDC) 
{
	// TODO: Add your message handler code here and/or call default
	
	return CView::OnEraseBkgnd(pDC);
}

void CRealTimeView::OnMove(int x, int y) 
{
	CView::OnMove(x, y);
	
	// TODO: Add your message handler code here
}

void CRealTimeView::OnDestroy() 
{
	CView::OnDestroy();

	KillTimer(0);

	if (m_bFirstPaint == FALSE)
	{
		delete [] m_pPortNum;
		return;
	}
	
	for (int i = 0; i < m_iKilnNum; i++)
	{
		// 释放每条窑的表头资源
		for (int j = 0; j < m_pPortNum[i]; j++)
		{
			delete m_pRTPort[i]->m_pSegPort[j];
		}

		// 释放每条窑的表头指针列表
		delete [] m_pRTPort[i]->m_pSegPort;

		// 释放每条窑的实时数据结构
		delete m_pRTPort[i];
	}

	delete [] m_pPortNum;

	// 释放窑的实时数据结构指针列表
	delete [] m_pRTPort;

	DeleteObject(m_HbtMap);
	DeleteDC(m_MemDcDraw);
}

void CRealTimeView::OnTimer(UINT nIDEvent) 
{
	// TODO: Add your message handler code here and/or call default
	UpdateView();				// 自己定时更新
	
	CView::OnTimer(nIDEvent);
}
