// iComAPI.cpp: implementation of the CiComAPI class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <assert.h>
#include "iComAPI.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CiComAPI::CiComAPI()
{
}

CiComAPI::CiComAPI(int iComPort, 
				   char cPrity, 
				   int iBaudrate, 
				   int iDataBits, 
				   int iStopBits, 
				   int iTimeout, 
				   int iScanTime,
				   int DevNum)
{
	RegisterWindowClass();

	m_iComPort       = iComPort;
	m_cPrity         = cPrity;
	m_iBaudrate      = iBaudrate;
	m_iDataBits      = iDataBits;
	m_iStopBits      = iStopBits;
	m_iTimeout       = iTimeout;
	m_iScanTime      = iScanTime;

	m_DevNum = DevNum;						// 设备总数
	if (m_DevNum <= 0)
	{
		m_pTemObjectBuff = NULL;
	}
	else
	{
		m_pTemObjectBuff = new TemObject[m_DevNum];		// 创建设备信息缓冲区
		for (int i = 0; i < m_DevNum; i++)
		{
			m_pTemObjectBuff[i].pTemRegBuff = NULL;
		}
	}

	m_pModBus = NULL;
}

CiComAPI::~CiComAPI()
{
}

BEGIN_MESSAGE_MAP(CiComAPI, CWnd)
	//{{AFX_MSG_MAP(CModBus)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		ON_MESSAGE(WM_UPDATE_TERMINAL, OnUpdateTerminal)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Register the window class if it has not already been registered.
BOOL CiComAPI::RegisterWindowClass()
{
    WNDCLASS wndcls;
    //HINSTANCE hInst = AfxGetInstanceHandle();
    HINSTANCE hInst = AfxGetResourceHandle();
	
    if (!(::GetClassInfo(hInst, ICOMAPI_CLASSNAME, &wndcls)))
    {
        // otherwise we need to register a new class
        wndcls.style            = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
        wndcls.lpfnWndProc      = ::DefWindowProc;
        wndcls.cbClsExtra       = wndcls.cbWndExtra = 0;
        wndcls.hInstance        = hInst;
        wndcls.hIcon            = NULL;
        wndcls.hCursor          = 0;
        wndcls.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wndcls.lpszMenuName     = NULL;
        wndcls.lpszClassName    = ICOMAPI_CLASSNAME;
		
        if (!AfxRegisterClass(&wndcls))
        {
            AfxThrowResourceException();
            return FALSE;
        }
    }
	
    return TRUE;
}

BOOL CiComAPI::ImportDevInfo(int TemIdx, BYTE TemId, BYTE TemCmd, BYTE TemChn, WORD TemAddr, BYTE TemTyp)
{
	if (TemIdx > m_DevNum)
	{
		return FALSE;
	}

	m_pTemObjectBuff[TemIdx].TemId   = TemId;
	m_pTemObjectBuff[TemIdx].TemCmd  = TemCmd;
	m_pTemObjectBuff[TemIdx].TemChn  = TemChn;
	m_pTemObjectBuff[TemIdx].TemAddr = TemAddr;
	m_pTemObjectBuff[TemIdx].TemTyp  = TemTyp;

	return TRUE;
}

BOOL CiComAPI::Create(CWnd* pParentWnd, UINT nID, DWORD dwStyle)
{
	assert(pParentWnd->GetSafeHwnd());
	m_pParentWnd = pParentWnd;				// 存储父窗口指针
	
    if (!CWnd::Create(ICOMAPI_CLASSNAME, NULL, dwStyle, CRect(0, 0, 0, 0), pParentWnd, nID))
	{
        return FALSE;
	}

	/* 父类调用此函数前, 确认赋值设备信息 */
	for (int i = 0; i < m_DevNum; i++)
	{
		/* 创建设备缓冲区 */
		if ((m_pTemObjectBuff[i].TemChn > 0) && (m_pTemObjectBuff[i].pTemRegBuff == NULL))
		{
			m_pTemObjectBuff[i].pTemRegBuff = new WORD[m_pTemObjectBuff[i].TemChn];
		}
	}

	m_pModBus = new CModBus(this, 
							m_iComPort,				// 端口号
							m_iBaudrate,			// 波特率
							m_cPrity,				// 校验方式
							m_iDataBits,			// 数据位数
							m_iStopBits,			// 停止位数
							1024,					// 缓冲区容量
							m_iTimeout,				// 超时时间
							m_iScanTime,			// 扫描间隔时间
						    m_DevNum,				// 终端数量
							m_pTemObjectBuff);		
	
	if (m_pModBus->Create(this, 9900, WS_CHILD) == FALSE)
	{		
		return FALSE;
	}

	return TRUE;
}

// 消息函数
LONG CiComAPI::OnUpdateTerminal(WPARAM index, LPARAM len)
{
	if (m_pModBus->GetRegisterValue() == TRUE)
	{
		// 一次扫描完成, 发送消息到父类
		::SendMessage(m_pParentWnd->GetSafeHwnd(), WM_RX_TERMINAL, (WPARAM) 0, (LPARAM) 0);
		return 1;
	}

	return 0;
}

void CiComAPI::SetWriteTerminalInfo(int iTemIdx, WORD iTemWriteAddr, WORD iTemWriteRegs, WORD *pTemRegBuff)
{
	m_pModBus->SetWriteTerminalInfo(iTemIdx, iTemWriteAddr, iTemWriteRegs, pTemRegBuff);
}

void CiComAPI::DestroyWindows()
{
	m_pModBus->DestroyWindows();

	if (m_pTemObjectBuff != NULL)
	{
		for (int i = 0; i < m_DevNum; i++)
		{
			if (m_pTemObjectBuff[i].pTemRegBuff != NULL)
			{
				delete [] m_pTemObjectBuff[i].pTemRegBuff;
			}
		}

		delete [] m_pTemObjectBuff;
	}
	
	if (m_pModBus != NULL)
	{
		delete m_pModBus;
	}
}